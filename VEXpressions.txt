# Lines starting with # are comments and ignored
#
# Each entry starts with no indentation and gives the key used
# by the menu callback.  By convention, this is nodename/parmname.
# Multiply keys can be given for the same entry.
#
# The next line gives the name of the expression.  Its indentation
# level is then used for the remainder of the text.  All the
# code until the next parameter are appended together to make
# the snippet.  All preceeding indentation is removed.
# Note that tabs == 8 is assumed.

#
# POPs
#

popfan/localexpression
    Pass Through
    // Center:
    t = t;
    // Cone angle:
    cone = cone;
    dir = dir;
    windspeed = windspeed;
    airresist = airresist;

popfan/localexpression
    Randomize Airresist by Id
    airresist *= rand(@id);

popfilamentforce/localexpression
    Pass Through
    velscale = velscale;
    airresist = airresist;
    forcescale = forcescale;
    velblend = velblend;

popfilamentforce/localexpression
    Randomize by Id
    airresist *= rand(@id);
    forcescale *= rand(@id);

popforce/localforceexpression
    Randomize Magnitude
    // Assign to a float to force rand to scalar.
    // 0.5 and 1.0 are the min and max scales
    float amt = rand(@id);
    force *= fit01(amt, 0.5, 1.0);

popforce/localforceexpression
    Orbit the Origin
    // length(force) ensures the parameter
    // still has an effect on the scale of
    // the orbit
    vector axis = { 0, 1, 0 };
    vector center = { 0, 0, 0 };
    force = length(force) * cross(@P-center, axis);

popforce/localforceexpression
    Force Until Velocity Reached
    float threshold = 2.0;	// Cut off
    float speed = length(@v);
    
    if (speed > threshold)
    {
	force = 0;
    }

popforce/localforceexpression
    Scale Force According to Proximity to Point
    vector pos = { 0, 2, 0 };	// Point Position
    float radius = 1.0;	        // Radius of effect
    float dist = length(@P - pos);
    dist /= radius;             // Normalize distance
    //force *= 1 - clamp(dist, 0, 1); // simple linear force
    force *= smooth(0, 1, 1-dist); // reversed ease in-out force


popforce/localnoiseexpression
popwind/localnoiseexpression
    Amplitude by Age
    // Ease in using age in seconds
    amp *= smooth(0, 1.5, @age);    

popforce/localnoiseexpression
popwind/localnoiseexpression
    Amplitude by Normalized Age
    // Ease in based on percentage life
    amp *= smooth(0, 0.2, @nage); 

popforce/localnoiseexpression
popwind/localnoiseexpression
    Amplitude by Speed
    // speed determines amplitude of effect
    float min = 0.5;    // minimum speed threshold
    float max = 1.0;    // maximum speed threshold
    float width = 0.1;  // ease in and out feather width
    float vmag = clamp(length(@v), min, max);
    amp *= smooth(min, min + width, vmag) - smooth(max - width, max, vmag);

popforce/localnoiseexpression
popwind/localnoiseexpression
    Scale by Velocity
    // boost noise for lower velocity values
    amp *= fit(length(@v), 0, 0.5, 2, 1);

popdrag/localdragexpression
    Drag by Proximity to Point
    vector target = {0, 1, 0};         // Target position
    float dist = length(@P - target);  // distance to target
    float radius = 2.0;	               // Effect radius
    dist = fit(dist, 0, radius, 0, 1); // fit to range
    airresist *= dist;

popdragspin/localdragexpression
    Drag by Proximity to Point
    vector target = {0, 1, 0};         // Target position
    float dist = length(@P - target);  // distance to target
    float radius = 2.0;	               // Effect radius
    dist = fit(dist, 0, radius, 0, 1); // fit to range
    spinresist *= dist;

popattract/goalcode
    Spread Goal
    float spread = 0.1;
    float seed = 0.1245;
    goal += spread * (vector(rand(@id+seed)) - 0.5);

popattract/forcecode
    Randomize Force Scale
    float	fmin = 0.1;
    float	fmax = 1.0;
    forcescale *= fit01( rand(@id), fmin, fmax );

popcolor/localconstant
    Color by Velocity Magnitude
    // Color red by velocity magnitude
    float vmax = 1.0;
    color = set(fit(length(@v), 0, vmax, 0, 1), 0, 0);


popcolor/localconstant
    Color by Condition
    // Condition is Position Y greater than 1.
    // Use any attribute test you wish.
    if (@P.y > 1.0)
    {
	color = color;	// Set to parameter value
    }
    else
    {
	color = @Cd;	// Restore
    }

popcolor/localconstant
    Color by Proximity
    vector center = {0,1,0};
    float  radius = 2.0;
    color = fit(length(@P - center), 0, radius, 1, 0); // reverse fit index

popinstance/localexpression
    Random Scale
    // Note you have to turn on the pscale option for this
    // to work!
    pscale *= rand(@id);

popkill/rulecode
    Kill by Condition
    dead = (@P.y > 1) ? 1 : 0;

poplocalforce/localforce
    Randomize Thrust, Lift and Side Slip
    float seed = 0.12345;
    thrust   *= fit01(rand(@id+seed),   0.5, 1);
    lift     *= fit01(rand(@id+seed+0.1),  0.5, 1);
    sideslip *= fit01(rand(@id+seed+0.2), 0.5, 1);

poplookat/code
    Orient to Velocity
    // Force mode to target is direction:
    mode = 1;
    target = @v;

popproperty/localexpression
    Randomize Mass
    float seed = 0.12345;
    mass *= fit01(rand(@id+seed), 0.7, 1);

popproperty/localexpression
    Randomize Particle Scale
    float seed = 0.12345;
    pscale *= fit01(rand(@id+seed), 0.5, 1.5);

popspeedlimit/localexpression
    Randomize Speed and Spin
    float seed = 0.12345;
    speedmin *= fit01(rand(@id+seed),    0.5, 1);
    speedmax *= fit01(rand(@id+seed+.1), 0.5, 1);
    spinmin  *= fit01(rand(@id+seed+.2), 0.5, 1);
    spinmax  *= fit01(rand(@id+seed+.3), 0.5, 1);

popvelocity/localexpression
    Pass Through
    scale = scale;
    v = v;

popvelocity/localexpression
    Scale Velocity
    v = @v * scale;

popvelocity/localexpression
    Project onto Vector
    vector nv = normalize(v);
    v = dot(nv, @v) * nv;

popvelocity/localexpression
    Project onto Plane
    vector nv = normalize(v);
    v = @v - dot(nv, @v) * nv;

popvelocity/localexpression
    Set Speed
    // The implicit multiplication by scale will
    // then set the speed.
    v = normalize(@v);

popspin/localexpression
    Pass Through
    // oldspinspeed also exists giving the
    // previous spin in degrees per second
    spinspeed = spinspeed;
    axis = axis;

popspin/localexpression
    Scale Spin Speed
    // We treat the spinspeed as a scale here
    // and ignore the axis.
    axis = @w;
    spinspeed = oldspinspeed * spinspeed;

popspin/localexpression
    Project onto Vector
    vector naxis = normalize(axis);
    axis = dot(naxis, @w) * naxis;
    // Construct the required spinspeed
    spinspeed = degrees( length(axis) );

popspin/localexpression
    Rotate onto Vector
    vector naxis = normalize(axis);
    axis = dot(naxis, @w) * naxis;
    spinspeed = oldspinspeed;

popspin/localexpression
    Project onto Plane
    vector naxis = normalize(axis);
    axis = @w - dot(naxis, @w) * naxis;
    // Construct the required spinspeed
    spinspeed = degrees( length(axis) );

popspin/localexpression
    Rotate onto Plane
    vector naxis = normalize(axis);
    axis = @w - dot(naxis, @w) * naxis;
    spinspeed = oldspinspeed;

popspin/localexpression
    Set Spin Speed
    // The implicit multiplication by spinspeed will
    // then set the speed.
    axis = @w;

#
# Point Wrangle
#
attribwrangle/snippet
    Add Value to Y Position
    @P += {0,1,0};

attribwrangle/snippet
    Flatten Points in Y
    @P = set(@P.x, 0, @P.z);

attribwrangle/snippet
    Add Random to Y Position:
    @P += set(@P.x, rand(@ptnum), @P.z);

attribwrangle/snippet
    Velocity from Surface Normals
    @v = @N; // v from surface normals

attribwrangle/snippet
    Color from Bounding Box
    @Cd = relbbox(0, @P);

attribwrangle/snippet
    Flared Y Velocity Attributes
    float  vely = 1.0;                // Velocity in Y
    vector offset = {0, 0, 0};       // Offset flare center
    float  seed = 0.12345; 	     // seed for rand
    float  randamt = 0.1;	     // amount of randomness to add
    vector bbox = relbbox(0, P);     // bounding box of point
    bbox += offset;		     // transform bbox by offset
    @v = set(bbox.x, vely, bbox.z);  // set v
    @v += rand(seed+@ptnum)*randamt;  // add noise to v

attribwrangle/snippet
    Percent pscale Along Curve:
    @pscale = @ptnum/(@Npt-1.0);  // initialize pscale
    //@pscale = spline("catmull-rom", index, 0,0,0.25,0.3,1,1);

attribwrangle/snippet
    Normalize Surface Normals
    @N = normalize(@N);  // normalize surface normals

attribwrangle/snippet
    Random Point Color:
    float seed = 0.12345; // seed for rand
    @Cd = rand(seed + @ptnum);

attribwrangle/snippet
    Random Y Velocity
    float seed = 0.12345;              // initialize seed
    @v = set(0, rand(@ptnum+seed), 0); // random velocity in Y

attribwrangle/snippet
    Simple Noise to Y Position
    @P = set(@P.x, @P.y + fit01(noise(@P),-1, 1)*0.5, @P.z);

attribwrangle/snippet
    Add Noise to Position
    float amp = 1;                    // amplitude of noise
    float time = Time * 0.5;          // speed time used in offset
    int seed = 1;                     // seed of noise
    int octaves = 1;                  // octaves for turbulence noise
    vector freq = {1,1,1};            // noise frequency
    vector offset = set(0, time, 0);  // animate offset with time in Y
    vector pos = ptransform("space:current", "space:world", @P);
    // uncomment the noise function below you want to use
    @P += noise(pos * freq + offset + seed) * amp;
    //@P += onoise(pos * freq + offset + seed) * amp;
    //@P += hscript_noise(pos * freq + offset + seed) * amp;
    //@P += hscript_rand(pos * freq + offset + seed) * amp; 
    //@P += hscript_turb(pos * freq + offset + seed, octaves) * amp;
    //@P += hscript_sturb(pos * freq + offset + seed, octaves) * amp;

attribwrangle/snippet
    Swap Point Position with Rest
    vector tmp = @P;
    @P = @rest;
    @rest = tmp;

attribwrangle/snippet
    Swap Point Position with UV
    vector tmp = @P;
    @P = @uv;
    @uv = tmp;

attribwrangle/snippet
    Color Based on Threshold
    int condition = (@P.x > 0) ? 1 : 0; // short form if() test
    @Cd = set(condition, 0, 0);        // write condition into red color


attribwrangle/snippet
    Point Group on Threshold
    string group = "mygroup";         // group name to add points to
    int condition = (@P.x > 0) ? 1: 0; // short form if() test
    if (condition)
	addgroup(group, @ptnum);       // if true add point to group
    @Cd = set( condition, 0, 0);      // color if in group

attribwrangle/snippet
    Fetch Second Input Position
    // Second input used as reference geometry
    @P = point(1, "P", @ptnum); // set second input position to first

attribwrangle/snippet
    Fetch Second Input Cd Attribute
    // Second input used as reference geometry
    @Cd = point(1, "Cd", @ptnum);


attribwrangle/snippet
    Fetch Second Input Attribute by id
    // grab attribute by id match from second input
    // id attribute present on both inputs for indexing
    int match_pt = findattribval(1, "point", "id", @id); // matching point
    @P = point(1, "P", match_pt);  // use matching point to fetch attribute

attribwrangle/snippet
    Nearest Point Distance
    // Second input used for reference geometry
    int closept = nearpoint(1, @P);	  // get point number of near point
    vector value = point(1, "P", closept);// get position of near point
    @dist = length(@P - value);           // export distance from nearest point
    @Cd = set(@dist, 0, 0);

#
# Attribute Wrangle
#
attribwrangle/snippet
    Color from Bounding Box
    @Cd = relbbox(0, @P);

attribwrangle/snippet
    Random Point Color:
    float seed = 0.12345; // seed for rand
    @Cd = rand(seed + @ptnum);

attribwrangle/snippet
    Color Based on Threshold
    int condition = (@P.x > 0) ? 1 : 0; // short form if() test
    @Cd = set(condition, 0, 0);        // write condition into red color

attribwrangle/snippet
    Point Group on Threshold
    string group = "mygroup";         // group name to add points to
    int condition = (@P.x > 0) ? 1: 0; // short form if() test
    setpointgroup(geoself(), group, @ptnum, condition);
    @Cd = set( condition, 0, 0);      // color if in group

attribwrangle/snippet
    Fetch Second Input Cd Attribute
    // Second input used as reference geometry
    // Use prim and @primnum to get a matching primitive attribute.
    @Cd = point(1, "Cd", @ptnum);

attribwrangle/snippet
    Fetch Second Input Attribute by id/name

    // grab attribute by id match from second input
    // id attribute present on both inputs for indexing
    int match_pt = findattribval(1, "point", "id", @id); // matching point
    @P = point(1, "P", match_pt);  // use matching point to fetch attribute

    // grab attribute by name attribute
    // int match_prim = findattribval(1, "prim", "name", @name); // matching name
    // @Cd = prim(1, "Cd", match_prim);

attribwrangle/snippet
    Nearest Point Distance
    // Second input used for reference geometry
    int closept = nearpoint(1, @P);	  // get point number of near point
    vector value = point(1, "P", closept);// get position of near point
    @dist = length(@P - value);           // export distance from nearest point
    @Cd = set(@dist, 0, 0);

attribwrangle/snippet
    Grow Hairs
    vector dir = { 0, 1, 0 };
    // dir = @N;	// grow in normal direction
    float len = 1.0;
    int   steps = 10;
    float jitter = 0.1;
    float seed = 0.12345;

    vector	pos = @P;
    int		pr = addprim(geoself(), "polyline");

    // Start the curve with our point
    addvertex(geoself(), pr, @ptnum);
    for (int i = 0; i < steps; i++)
    {
	pos += dir * len / steps;
	pos += (vector(rand( @ptnum + seed )) - 0.5) * jitter;

	// Clone our point to copy attributes
	int pt = addpoint(geoself(), @ptnum);
	// But write a new position
	setpointattrib(geoself(), "P", pt, pos);

	// Connect the new point to our curve.
	addvertex(geoself(), pr, pt);
	seed += $PI;
    }

attribwrangle/snippet
    Get Neighbouring Points into Attribute
    i[]@neighbours = neighbours(0, @ptnum);

attribwrangle/snippet
    Average Neighbouring Points
    int n[] = neighbours(0, @ptnum);
    vector avgP = @P;

    // Loops over all elements of n, setting pt
    // to be the value of each element
    foreach (int pt; n)
    {
	avgP += point(0, "P", pt);
    }

    // +1 because we included ourself.
    avgP /= len(n)+1;
    @P = avgP;

#
# VEX Deform
#
deformationwrangle/snippet
    Pass Through
    pos = pos;
    xform = xform;

deformationwrangle/snippet
    Twist
    // Hit the Plug button to generate the UI
    // and change axis.
    vector axis = chv('axis');
    vector center = chv('origin');
    float  rate = chf('rotations_per_distance');

    // Find where we are from the center along axis.
    axis = normalize(axis);
    float dist = dot(pos - center, axis);
    float amt = $PI * 2 * rate * dist;

    matrix3	rot = 1;
    rotate(rot, amt, axis);

    pos -= center;
    pos *= rot;
    pos += center;


#
# Volume Wrangle
#
volumewrangle/snippet
    Create Points where Positive
    // You may want to turn on Bind Each to Density to
    // apply to all volumes.
    if (@density > 0)
    {
	addpoint(geoself(), @P);
    }

#
# Popsteer POPs
#
popsteeralign/localforceexpression
    Randomize Force Scale per Particle
    forcescale = rand(@ptnum);

popsteeralign/localforceexpression
    Randomize Fov per Particle
    usefov = 1;
    fov = rand(@ptnum)*120;

popsteercohesion/localforceexpression
    Randomize Force Scale per Particle
    forcescale = rand(@ptnum)*10;

popsteercohesion/localforceexpression
    Randomize Fov per Particle
    usefov = 1;
    fov = rand(@ptnum)*120;

popsteerobstacle/localexpression
    Randomize Search Distance per Particle
    frontsearchdistance = rand(@ptnum)*10;
    sidesearchdistance = rand(@ptnum)*5;

popsteerobstacle/localexpression
    Scale Avoidance Force by Pscale
    avoidanceforcescale = 10*1/@pscale;
    breakingforcescale = 10*1/@pscale;

popsteerpath/localforceexpression
    Randomize Path Variance and Force per Particle
    forcescale = rand(@ptnum)*10;
    pathvariance = rand(@ptnum)*5;

popsteerseek/localgoalexpression
    Randomize Goal Position per Particle
    // Random goal position in (-10,10) range
    goal.x = (2*rand(@ptnum)-0.5)*10;
    goal.z = (2*rand(@ptnum)+123)-0.5)*10;

popsteerseek/localforceexpression
    Randomize Force Scale per Particle
    forcescale = rand(@ptnum)*10;

popsteerseparate/localforceexpression
    Randomize Force Scale per Particle
    forcescale = rand(@ptnum)*10;

popsteerseparate/localforceexpression
    Randomize Fov per Particle
    usefov = 1;
    fov = rand(@ptnum)*180;

popsteerseparate/localforceexpression
    Randomize Fov per Particle
    usefov = 1;
    fov = rand(@ptnum)*180;

popsteerwander/localforceexpression
    Randomize Force XZ direction per Particle
    force.x = (2*rand(@ptnum)-0.5)*10;
    force.z = (2*rand(@ptnum)+123)-0.5)*10;


sprite/localexpression
    Pass Through
    // 0: Uses offset/size
    // 1: Uses textureindex/row/col
    cropmode = cropmode;
    textureoffset = textureoffset;
    texturesize = texturesize;

    textureindex = textureindex;
    texturerow = texturerow;
    texturecol = texturecol;

    spriterot = spriterot;
    spritescale = spritescale;

#
# Group Expression
#
groupexpression/snippet
    Within radius 1 sphere of origin
    length(@P) < 1.0

groupexpression/snippet
    X coordinate less than 0
    @P.x < 0

groupexpression/snippet
    30% chance
    rand(@elemnum) < 0.3

#
# Attribute Expression
#
attribexpression/snippet
    Pass Through
    self

attribexpression/snippet
    Constant Value
    value

attribexpression/snippet
    Multiply by Constant Value
    self * value

attribexpression/snippet
    Add Constant Value
    self + value

attribexpression/snippet
    Random
    rand(@elemnum)

attribexpression/snippet
    Random Scale of Value
    value * float(rand(@elemnum))

attribexpression/snippet
    Random Offset of Value
    value + rand(@elemnum)

attribexpression/snippet
    Second Input's Position
    @opinput1_P

attribexpression/snippet
    Flatten Vector
    set(self.x, 0, self.z)

attribexpression/snippet
    Uniform Parameter on Polyline
    vertexprimindex(0, @vtxnum) / (primvertexcount(0, @primnum) - 1.0)

attribexpression/snippet
    Subtract Center of First Input
    self - getbbox_center(0)

attribexpression/snippet
    Spherify P
    lerp(self,(normalize(self - getbbox_center(0)) * ch("radius")) + getbbox_center(0),ch("Amt"))

attribexpression/snippet
    Spherify N
    @P - getbbox_center(0)

attribexpression/snippet
    Morph to 2nd Input
    lerp(self, point(1,"P",@ptnum),ch("Amt"))

# VEX Channel
#
channelwrangle/snippet
    Lookat
    matrix m1 = lookat(0, @t-chv("lookatvec"), chv("upvec") );

    // Rotate the lookat to point to a different axis.
    int mode = chi("rorder");
    if( mode>=0 && mode<=6 )
        m1 = maketransform( /*trs_order=*/0, /*rot_order=*/mode, /*t=*/0, /*r=*/chv("angle"), /*s=*/1 ) * m1;

    @r = cracktransform(0,0,1,0,m1); // Overwrite only the rotation

channelwrangle/snippet
    Identity
    @t = 0;
    @r = 0;
    @s = 1;

channelwrangle/snippet
    Distance
    chopTRS c0 = c->fetchInput(0);
    chopTRS c1 = c->fetchInput(1);

    // Compute the vector betweem first and second input.
    // and scale it with a radius parm
    vector dt = normalize(c1.t - c0.t)* chf('radius');

    @t = c0.t + dt; // Translation from first input + radius vector 
    @r = c1.r;      // Rotation from second input
    @s = c0.s;      // Scale from first input


